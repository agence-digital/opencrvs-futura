{
    "sourceFile": "src/form/custom-fields.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 6,
            "patches": [
                {
                    "date": 1713968115386,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1713968199070,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -241,9 +241,10 @@\n     label: formMessageDescriptors.birthOrder,\n     initialValue: '',\n     validator: [\n       {\n-        operation: 'greaterThanZero'\n+        operation: 'greaterThanZero',\n+        parameters: [50]\n       },\n       {\n         operation: 'maxLength',\n         parameters: [2]\n"
                },
                {
                    "date": 1713968263277,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -241,10 +241,10 @@\n     label: formMessageDescriptors.birthOrder,\n     initialValue: '',\n     validator: [\n       {\n-        operation: 'greaterThanZero',\n-        parameters: [50]\n+        operation: 'range',\n+        parameters: [0, 50]\n       },\n       {\n         operation: 'maxLength',\n         parameters: [2]\n"
                },
                {
                    "date": 1713968355812,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -242,9 +242,9 @@\n     initialValue: '',\n     validator: [\n       {\n         operation: 'range',\n-        parameters: [0, 50]\n+        parameters: [1, 50]\n       },\n       {\n         operation: 'maxLength',\n         parameters: [2]\n"
                },
                {
                    "date": 1713968507760,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -274,10 +274,10 @@\n     label: formMessageDescriptors.totalNumberOfChildrenBornAlive,\n     initialValue: '',\n     validator: [\n       {\n-        operation: 'greaterThanZero',\n-        parameters: [50]\n+        operation: 'range',\n+        parameters: [1, 50]\n       },\n       {\n         operation: 'maxLength',\n         parameters: [2]\n@@ -307,10 +307,10 @@\n     label: formMessageDescriptors.childrenStillLivingIncludingThisBirth,\n     initialValue: '',\n     validator: [\n       {\n-        operation: 'greaterThanZero',\n-        parameters: [50]\n+        operation: 'range',\n+        parameters: [1, 50]\n       },\n       {\n         operation: 'maxLength',\n         parameters: [2]\n"
                },
                {
                    "date": 1713968544332,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,504 @@\n+/*\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n+ *\n+ * OpenCRVS is also distributed under the terms of the Civil Registration\n+ * & Healthcare Disclaimer located at http://opencrvs.org/license.\n+ *\n+ * Copyright (C) The OpenCRVS Authors located at https://github.com/opencrvs/opencrvs-core/blob/master/AUTHORS.\n+ */\n+import { MessageDescriptor } from 'react-intl'\n+import { formMessageDescriptors } from './common/messages'\n+import { Conditional, SerializedFormField } from './types/types'\n+import { getCustomFieldMapping } from '@countryconfig/utils/mapping/field-mapping-utils'\n+import { getNationalIDValidators } from './common/default-validation-conditionals'\n+import { camelCase } from 'lodash'\n+import { uppercaseFirstLetter } from '@countryconfig/utils'\n+\n+// ======================= CUSTOM FIELD CONFIGURATION =======================\n+\n+// A CUSTOM FIELD CAN BE ADDED TO APPEAR IN ANY SECTION\n+// DUPLICATE AND RENAME FUNCTIONS LIKE THESE IN ORDER TO USE SIMILAR FIELDS\n+\n+export function createCustomFieldExample(): SerializedFormField {\n+  // GIVE THE FIELD A UNIQUE NAME.  IF THE NAME IS ALREADY IN USE, YOU WILL NOTICE AN ERROR ON PAGE LOAD IN DEVELOPMENT\n+  const fieldName: string = 'favoriteColor'\n+  // THE fieldId STRING IS A DOT SEPARATED STRING AND IS IMPORTANT TO SET CORRECTLY DEPENDING ON WHERE THE CUSTOM FIELD IS LOCATED\n+  // THE FORMAT IS event.sectionId.groupId.uniqueFieldName\n+  const fieldId: string = `birth.child.child-view-group.${fieldName}`\n+  // IN ORDER TO USE THE VALUE ON A CERTIFICATE\n+  // THE groupId IS IGNORED AND THE HANDLEBAR WILL LOG IN THE CONSOLE\n+  // IN THIS EXAMPLE, IT WILL RESOLVE IN CAMELCASE TO \"{{birthChildFavouriteColor}}\"\n+\n+  return {\n+    name: fieldName,\n+    customQuestionMappingId: fieldId,\n+    custom: true,\n+    required: true,\n+    type: 'TEXT', // ANY FORM FIELD TYPE IS POSSIBLE. ADD ADDITIONAL PROPS AS REQUIRED.  REFER TO THE form/README.md FILE\n+    label: {\n+      id: 'form.customField.label.favoriteColor',\n+      description: 'A form field that asks for the persons favorite color.',\n+      defaultMessage: 'What is your favorite color?'\n+    },\n+    initialValue: '',\n+    validator: [], // EDIT VALIDATORS AS YOU SEE FIT\n+    mapping: getCustomFieldMapping(fieldId), // ALL CUSTOM FIELDS MUST USE THIS MAPPING FUNCTION\n+    conditionals: [], // EDIT CONDITIONALS AS YOU SEE FIT\n+    maxLength: 250\n+  }\n+}\n+\n+export function getMiddleNameField(\n+  middleName: string,\n+  previewGroup: string,\n+  conditionals: Conditional[]\n+): SerializedFormField {\n+  // GIVE THE FIELD A UNIQUE NAME.  IF THE NAME IS ALREADY IN USE, YOU WILL NOTICE AN ERROR ON PAGE LOAD IN DEVELOPMENT\n+  const fieldName: string = 'middleNamesEng'\n+  // THE fieldId STRING IS A DOT SEPARATED STRING AND IS IMPORTANT TO SET CORRECTLY DEPENDING ON WHERE THE CUSTOM FIELD IS LOCATED\n+  // THE FORMAT IS event.sectionId.groupId.uniqueFieldName\n+  let lol\n+\n+  switch (middleName) {\n+    case 'child':\n+      lol = 'birth.child.child-view-group'\n+      break\n+    case 'mother':\n+      lol = 'birth.mother.mother-view-group'\n+      break\n+    case 'father':\n+      lol = 'birth.father.father-view-group'\n+      break\n+    case 'informant':\n+      lol = 'birth.informant.informant-view-group'\n+      break\n+    default:\n+      lol = 'birth.child.father-view-group' // Or a more appropriate default based on your logic\n+  }\n+  const fieldId: string = `${lol}.${fieldName}`\n+  // IN ORDER TO USE THE VALUE ON A CERTIFICATE\n+  // THE groupId IS IGNORED AND THE HANDLEBAR WILL LOG IN THE CONSOLE\n+  // IN THIS EXAMPLE, IT WILL RESOLVE IN CAMELCASE TO \"{{birthChildFavouriteColor}}\"\n+\n+  return {\n+    name: fieldName,\n+    previewGroup,\n+    conditionals,\n+    customQuestionMappingId: fieldId,\n+    custom: true,\n+    required: true,\n+    type: 'TEXT', // ANY FORM FIELD TYPE IS POSSIBLE. ADD ADDITIONAL PROPS AS REQUIRED.  REFER TO THE form/README.md FILE\n+    label: formMessageDescriptors.middleName,\n+    initialValue: '',\n+    validator: [\n+      {\n+        operation: 'englishOnlyNameFormat'\n+      }\n+    ], // EDIT VALIDATORS AS YOU SEE FIT\n+    mapping: getCustomFieldMapping(fieldId), // ALL CUSTOM FIELDS MUST USE THIS MAPPING FUNCTION\n+    maxLength: 32\n+  }\n+}\n+\n+export function getSpecifyRankField(): SerializedFormField {\n+  // GIVE THE FIELD A UNIQUE NAME.  IF THE NAME IS ALREADY IN USE, YOU WILL NOTICE AN ERROR ON PAGE LOAD IN DEVELOPMENT\n+  const fieldName: string = 'specifyRank'\n+  // THE fieldId STRING IS A DOT SEPARATED STRING AND IS IMPORTANT TO SET CORRECTLY DEPENDING ON WHERE THE CUSTOM FIELD IS LOCATED\n+  // THE FORMAT IS event.sectionId.groupId.uniqueFieldName\n+  const fieldId: string = `birth.child.child-view-group.${fieldName}`\n+  // IN ORDER TO USE THE VALUE ON A CERTIFICATE\n+  // THE groupId IS IGNORED AND THE HANDLEBAR WILL LOG IN THE CONSOLE\n+  // IN THIS EXAMPLE, IT WILL RESOLVE IN CAMELCASE TO \"{{birthChildFavouriteColor}}\"\n+\n+  return {\n+    name: fieldName,\n+    customQuestionMappingId: fieldId,\n+    custom: true,\n+    required: false,\n+    type: 'NUMBER', // ANY FORM FIELD TYPE IS POSSIBLE. ADD ADDITIONAL PROPS AS REQUIRED.  REFER TO THE form/README.md FILE\n+    label: formMessageDescriptors.specifyRank,\n+    initialValue: '',\n+    validator: [\n+      {\n+        operation: 'greaterThanZero'\n+      },\n+      {\n+        operation: 'maxLength',\n+        parameters: [2]\n+      }\n+    ], // EDIT VALIDATORS AS YOU SEE FIT\n+    mapping: getCustomFieldMapping(fieldId), // ALL CUSTOM FIELDS MUST USE THIS MAPPING FUNCTION\n+    conditionals: [\n+      {\n+        action: 'hide',\n+        expression: `((values.birthType===\"SINGLE\") || (!values.birthType))`\n+      }\n+    ] // EDIT CONDITIONALS AS YOU SEE FIT\n+  }\n+}\n+\n+export function getAgeTimeOfbirthField(ageBirth: string): SerializedFormField {\n+  // GIVE THE FIELD A UNIQUE NAME.  IF THE NAME IS ALREADY IN USE, YOU WILL NOTICE AN ERROR ON PAGE LOAD IN DEVELOPMENT\n+  const fieldName: string = 'ageTimeOfbirth'\n+  // THE fieldId STRING IS A DOT SEPARATED STRING AND IS IMPORTANT TO SET CORRECTLY DEPENDING ON WHERE THE CUSTOM FIELD IS LOCATED\n+  // THE FORMAT IS event.sectionId.groupId.uniqueFieldName\n+  let age\n+\n+  switch (ageBirth) {\n+    case 'mother':\n+      age = 'birth.mother.mother-view-group'\n+      break\n+    case 'father':\n+      age = 'birth.father.father-view-group'\n+      break\n+    default:\n+      age = 'birth.child.father-view-group' // Or a more appropriate default based on your logic\n+  }\n+  const fieldId: string = `${age}.${fieldName}`\n+  // IN ORDER TO USE THE VALUE ON A CERTIFICATE\n+  // THE groupId IS IGNORED AND THE HANDLEBAR WILL LOG IN THE CONSOLE\n+  // IN THIS EXAMPLE, IT WILL RESOLVE IN CAMELCASE TO \"{{birthChildFavouriteColor}}\"\n+\n+  return {\n+    name: fieldName,\n+    customQuestionMappingId: fieldId,\n+    custom: true,\n+    required: false,\n+    type: 'NUMBER', // ANY FORM FIELD TYPE IS POSSIBLE. ADD ADDITIONAL PROPS AS REQUIRED.  REFER TO THE form/README.md FILE\n+    label: formMessageDescriptors.ageTimeOfbirth,\n+    initialValue: '',\n+    validator: [\n+      {\n+        operation: 'greaterThanZero',\n+        parameters: [8]\n+      },\n+      {\n+        operation: 'maxLength',\n+        parameters: [2]\n+      }\n+    ], // EDIT VALIDATORS AS YOU SEE FIT\n+    mapping: getCustomFieldMapping(fieldId), // ALL CUSTOM FIELDS MUST USE THIS MAPPING FUNCTION\n+    conditionals: [] // EDIT CONDITIONALS AS YOU SEE FIT\n+  }\n+}\n+\n+export function getDateMarriageField(): SerializedFormField {\n+  // GIVE THE FIELD A UNIQUE NAME.  IF THE NAME IS ALREADY IN USE, YOU WILL NOTICE AN ERROR ON PAGE LOAD IN DEVELOPMENT\n+  const fieldName: string = 'dateMarriageOfParents'\n+  // THE fieldId STRING IS A DOT SEPARATED STRING AND IS IMPORTANT TO SET CORRECTLY DEPENDING ON WHERE THE CUSTOM FIELD IS LOCATED\n+  // THE FORMAT IS event.sectionId.groupId.uniqueFieldName\n+  const fieldId: string = `birth.father.father-view-group.${fieldName}`\n+  // IN ORDER TO USE THE VALUE ON A CERTIFICATE\n+  // THE groupId IS IGNORED AND THE HANDLEBAR WILL LOG IN THE CONSOLE\n+  // IN THIS EXAMPLE, IT WILL RESOLVE IN CAMELCASE TO \"{{birthChildFavouriteColor}}\"\n+\n+  return {\n+    name: fieldName,\n+    customQuestionMappingId: fieldId,\n+    custom: true,\n+    required: true,\n+    type: 'DATE', // ANY FORM FIELD TYPE IS POSSIBLE. ADD ADDITIONAL PROPS AS REQUIRED.  REFER TO THE form/README.md FILE\n+    label: formMessageDescriptors.dateMarriageOfParents,\n+    initialValue: '',\n+    validator: [\n+      {\n+        operation: 'dateFormatIsCorrect',\n+        parameters: []\n+      },\n+      {\n+        operation: 'dateInPast',\n+        parameters: []\n+      }\n+    ], // EDIT VALIDATORS AS YOU SEE FIT\n+    mapping: getCustomFieldMapping(fieldId), // ALL CUSTOM FIELDS MUST USE THIS MAPPING FUNCTION\n+    conditionals: [\n+      {\n+        action: 'hide',\n+        expression: `((values.maritalStatus===\"SINGLE\") || (values.maritalStatus===\"WIDOWED\") || (values.maritalStatus===\"DIVORCED\") || (values.maritalStatus===\"SEPARATED\") || (values.maritalStatus===\"NOT_STATED\") || (!values.maritalStatus))`\n+      }\n+    ] // EDIT CONDITIONALS AS YOU SEE FIT\n+  }\n+}\n+\n+export function getBirthOrderField(): SerializedFormField {\n+  // GIVE THE FIELD A UNIQUE NAME.  IF THE NAME IS ALREADY IN USE, YOU WILL NOTICE AN ERROR ON PAGE LOAD IN DEVELOPMENT\n+  const fieldName: string = 'birthOrder'\n+  // THE fieldId STRING IS A DOT SEPARATED STRING AND IS IMPORTANT TO SET CORRECTLY DEPENDING ON WHERE THE CUSTOM FIELD IS LOCATED\n+  // THE FORMAT IS event.sectionId.groupId.uniqueFieldName\n+  const fieldId: string = `birth.child.child-view-group.${fieldName}`\n+  // IN ORDER TO USE THE VALUE ON A CERTIFICATE\n+  // THE groupId IS IGNORED AND THE HANDLEBAR WILL LOG IN THE CONSOLE\n+  // IN THIS EXAMPLE, IT WILL RESOLVE IN CAMELCASE TO \"{{birthChildFavouriteColor}}\"\n+\n+  return {\n+    name: fieldName,\n+    customQuestionMappingId: fieldId,\n+    custom: true,\n+    required: false,\n+    type: 'NUMBER', // ANY FORM FIELD TYPE IS POSSIBLE. ADD ADDITIONAL PROPS AS REQUIRED.  REFER TO THE form/README.md FILE\n+    label: formMessageDescriptors.birthOrder,\n+    initialValue: '',\n+    validator: [\n+      {\n+        operation: 'range',\n+        parameters: [1, 50]\n+      },\n+      {\n+        operation: 'maxLength',\n+        parameters: [2]\n+      }\n+    ], // EDIT VALIDATORS AS YOU SEE FIT\n+    mapping: getCustomFieldMapping(fieldId), // ALL CUSTOM FIELDS MUST USE THIS MAPPING FUNCTION\n+    conditionals: [] // EDIT CONDITIONALS AS YOU SEE FIT\n+  }\n+}\n+\n+export function getTotalNumberOfChildrenBornAliveField(): SerializedFormField {\n+  // GIVE THE FIELD A UNIQUE NAME.  IF THE NAME IS ALREADY IN USE, YOU WILL NOTICE AN ERROR ON PAGE LOAD IN DEVELOPMENT\n+  const fieldName: string = 'totalNumberOfChildrenBornAlive'\n+  // THE fieldId STRING IS A DOT SEPARATED STRING AND IS IMPORTANT TO SET CORRECTLY DEPENDING ON WHERE THE CUSTOM FIELD IS LOCATED\n+  // THE FORMAT IS event.sectionId.groupId.uniqueFieldName\n+  const fieldId: string = `birth.mother.mother-view-group.${fieldName}`\n+  // IN ORDER TO USE THE VALUE ON A CERTIFICATE\n+  // THE groupId IS IGNORED AND THE HANDLEBAR WILL LOG IN THE CONSOLE\n+  // IN THIS EXAMPLE, IT WILL RESOLVE IN CAMELCASE TO \"{{birthChildFavouriteColor}}\"\n+\n+  return {\n+    name: fieldName,\n+    customQuestionMappingId: fieldId,\n+    custom: true,\n+    required: false,\n+    type: 'NUMBER', // ANY FORM FIELD TYPE IS POSSIBLE. ADD ADDITIONAL PROPS AS REQUIRED.  REFER TO THE form/README.md FILE\n+    label: formMessageDescriptors.totalNumberOfChildrenBornAlive,\n+    initialValue: '',\n+    validator: [\n+      {\n+        operation: 'range',\n+        parameters: [0, 50]\n+      },\n+      {\n+        operation: 'maxLength',\n+        parameters: [2]\n+      }\n+    ], // EDIT VALIDATORS AS YOU SEE FIT\n+    mapping: getCustomFieldMapping(fieldId), // ALL CUSTOM FIELDS MUST USE THIS MAPPING FUNCTION\n+    conditionals: [] // EDIT CONDITIONALS AS YOU SEE FIT\n+  }\n+}\n+\n+export function getChildrenStillLivingIncludingThisBirthField(): SerializedFormField {\n+  // GIVE THE FIELD A UNIQUE NAME.  IF THE NAME IS ALREADY IN USE, YOU WILL NOTICE AN ERROR ON PAGE LOAD IN DEVELOPMENT\n+  const fieldName: string = 'childrenStillLivingIncludingThisBirth'\n+  // THE fieldId STRING IS A DOT SEPARATED STRING AND IS IMPORTANT TO SET CORRECTLY DEPENDING ON WHERE THE CUSTOM FIELD IS LOCATED\n+  // THE FORMAT IS event.sectionId.groupId.uniqueFieldName\n+  const fieldId: string = `birth.mother.mother-view-group.${fieldName}`\n+  // IN ORDER TO USE THE VALUE ON A CERTIFICATE\n+  // THE groupId IS IGNORED AND THE HANDLEBAR WILL LOG IN THE CONSOLE\n+  // IN THIS EXAMPLE, IT WILL RESOLVE IN CAMELCASE TO \"{{birthChildFavouriteColor}}\"\n+\n+  return {\n+    name: fieldName,\n+    customQuestionMappingId: fieldId,\n+    custom: true,\n+    required: false,\n+    type: 'NUMBER', // ANY FORM FIELD TYPE IS POSSIBLE. ADD ADDITIONAL PROPS AS REQUIRED.  REFER TO THE form/README.md FILE\n+    label: formMessageDescriptors.childrenStillLivingIncludingThisBirth,\n+    initialValue: '',\n+    validator: [\n+      {\n+        operation: 'range',\n+        parameters: [0, 50]\n+      },\n+      {\n+        operation: 'maxLength',\n+        parameters: [2]\n+      }\n+    ], // EDIT VALIDATORS AS YOU SEE FIT\n+    mapping: getCustomFieldMapping(fieldId), // ALL CUSTOM FIELDS MUST USE THIS MAPPING FUNCTION\n+    conditionals: [] // EDIT CONDITIONALS AS YOU SEE FIT\n+  }\n+}\n+\n+export function getReasonForLateRegistration(\n+  event: string\n+): SerializedFormField {\n+  const fieldName: string = 'reasonForLateRegistration'\n+  const fieldId: string =\n+    event === 'birth'\n+      ? `birth.child.child-view-group.${fieldName}`\n+      : `death.deathEvent.death-event-details.${fieldName}`\n+  const label: MessageDescriptor =\n+    event === 'birth'\n+      ? {\n+          id: 'form.customField.label.reasonForLateRegistrationBirth',\n+          description:\n+            'A form field that asks the reason for a late registration.',\n+          defaultMessage: 'Reason for delayed registration'\n+        }\n+      : {\n+          id: 'form.customField.label.reasonForLateRegistrationDeath',\n+          description:\n+            'A form field that asks the reason for a late registration.',\n+          defaultMessage: 'Reason for late registration'\n+        }\n+  const expression: string =\n+    event === 'birth'\n+      ? 'const pattern = /^\\\\d{4}-\\\\d{1,2}-\\\\d{1,2}$/; const today = new Date(); const eventDatePlusLateRegistrationTarget = new Date(values.childBirthDate); const lateRegistrationTarget = offlineCountryConfig && offlineCountryConfig.config.BIRTH.LATE_REGISTRATION_TARGET; eventDatePlusLateRegistrationTarget.setDate(eventDatePlusLateRegistrationTarget.getDate() + lateRegistrationTarget); !pattern.test(values.childBirthDate) || today < eventDatePlusLateRegistrationTarget;'\n+      : 'const pattern = /^\\\\d{4}-\\\\d{1,2}-\\\\d{1,2}$/; const today = new Date(); const eventDatePlusLateRegistrationTarget = new Date(values.deathDate); const lateRegistrationTarget = offlineCountryConfig && offlineCountryConfig.config.DEATH.REGISTRATION_TARGET; eventDatePlusLateRegistrationTarget.setDate(eventDatePlusLateRegistrationTarget.getDate() + lateRegistrationTarget); !pattern.test(values.deathDate) || today < eventDatePlusLateRegistrationTarget;'\n+\n+  return {\n+    name: fieldName,\n+    customQuestionMappingId: fieldId,\n+    custom: true,\n+    required: true,\n+    type: 'TEXT',\n+    label,\n+    initialValue: '',\n+    validator: [],\n+    mapping: getCustomFieldMapping(fieldId),\n+    conditionals: [\n+      {\n+        action: 'hide',\n+        expression\n+      }\n+    ], // EDIT CONDITIONALS AS YOU SEE FIT\n+    maxLength: 250\n+  }\n+}\n+\n+type ArrayElement<ArrayType> = ArrayType extends readonly (infer ElementType)[]\n+  ? ElementType\n+  : never\n+\n+const idTypeOptions = [\n+  {\n+    value: 'NATIONAL_ID' as const,\n+    label: {\n+      defaultMessage: 'National ID',\n+      description: 'Option for form field: Type of ID',\n+      id: 'form.field.label.iDTypeNationalID'\n+    }\n+  },\n+  {\n+    value: 'PASSPORT' as const,\n+    label: {\n+      defaultMessage: 'Passport',\n+      description: 'Option for form field: Type of ID',\n+      id: 'form.field.label.iDTypePassport'\n+    }\n+  },\n+  {\n+    value: 'BIRTH_REGISTRATION_NUMBER' as const,\n+    label: {\n+      defaultMessage: 'Birth Registration Number',\n+      description: 'Option for form field: Type of ID',\n+      id: 'form.field.label.iDTypeBRN'\n+    }\n+  },\n+  {\n+    value: 'NONE' as const,\n+    label: {\n+      defaultMessage: 'None',\n+      description: 'Option for form field: Type of ID',\n+      id: 'form.field.label.iDTypeNone'\n+    }\n+  }\n+]\n+\n+type IDType = ArrayElement<typeof idTypeOptions>['value']\n+\n+export function getIDType(\n+  event: string,\n+  sectionId: string,\n+  conditionals: Conditional[] = [],\n+  required: boolean\n+): SerializedFormField {\n+  const fieldName: string = `${sectionId}IdType`\n+  const fieldId: string = `${event}.${sectionId}.${sectionId}-view-group.${fieldName}`\n+  return {\n+    name: fieldName,\n+    customQuestionMappingId: fieldId,\n+    custom: true,\n+    required,\n+    type: 'SELECT_WITH_OPTIONS',\n+    label: {\n+      id: 'form.field.label.iDType',\n+      description: 'A form field that asks for the type of ID.',\n+      defaultMessage: 'Type of ID'\n+    },\n+    initialValue: '',\n+    validator: [],\n+    mapping: getCustomFieldMapping(fieldId),\n+    placeholder: formMessageDescriptors.formSelectPlaceholder,\n+    conditionals,\n+    options: idTypeOptions\n+  }\n+}\n+\n+function getValidators(configCase: string, idValue: IDType) {\n+  if (idValue === 'NATIONAL_ID') {\n+    return getNationalIDValidators(configCase)\n+  }\n+  return []\n+}\n+\n+export function getIDNumber(\n+  sectionId: string,\n+  idValue: IDType,\n+  conditionals: Conditional[] = [],\n+  required: boolean\n+): SerializedFormField {\n+  const fieldName: string = `${sectionId}${uppercaseFirstLetter(\n+    camelCase(idValue)\n+  )}`\n+  const validators = getValidators(sectionId, idValue)\n+  // eslint-disable-next-line no-console\n+  console.log('Custom field addded with handlebar: ', fieldName)\n+  return {\n+    name: fieldName,\n+    required,\n+    type: 'TEXT',\n+    custom: true,\n+    label: {\n+      id: 'form.field.label.iD',\n+      description: 'A form field that asks for the id number.',\n+      defaultMessage: 'ID number'\n+    },\n+    initialValue: '',\n+    validator: validators,\n+    mapping: {\n+      template: {\n+        fieldName: fieldName,\n+        operation: 'identityToFieldTransformer',\n+        parameters: ['id', idValue]\n+      },\n+      mutation: {\n+        operation: 'fieldToIdentityTransformer',\n+        parameters: ['id', idValue]\n+      },\n+      query: {\n+        operation: 'identityToFieldTransformer',\n+        parameters: ['id', idValue]\n+      }\n+    },\n+    conditionals: [\n+      {\n+        action: 'hide',\n+        expression: `(values.${sectionId}IdType!==\"${idValue}\") || (values.${sectionId}IdType===\"NONE\")`\n+      }\n+    ].concat(conditionals),\n+    maxLength: 250\n+  }\n+}\n+\n+export function getIDNumberFields(\n+  section: string,\n+  conditionals: Conditional[] = [],\n+  required: boolean\n+) {\n+  return idTypeOptions\n+    .filter((opt) => opt.value !== 'NONE')\n+    .map((opt) => getIDNumber(section, opt.value, conditionals, required))\n+}\n"
                },
                {
                    "date": 1713968587804,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -170,14 +170,14 @@\n     label: formMessageDescriptors.ageTimeOfbirth,\n     initialValue: '',\n     validator: [\n       {\n-        operation: 'greaterThanZero',\n-        parameters: [8]\n+        operation: 'range',\n+        parameters: [14, 120]\n       },\n       {\n         operation: 'maxLength',\n-        parameters: [2]\n+        parameters: [3]\n       }\n     ], // EDIT VALIDATORS AS YOU SEE FIT\n     mapping: getCustomFieldMapping(fieldId), // ALL CUSTOM FIELDS MUST USE THIS MAPPING FUNCTION\n     conditionals: [] // EDIT CONDITIONALS AS YOU SEE FIT\n"
                }
            ],
            "date": 1713968115386,
            "name": "Commit-0",
            "content": "/*\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n *\n * OpenCRVS is also distributed under the terms of the Civil Registration\n * & Healthcare Disclaimer located at http://opencrvs.org/license.\n *\n * Copyright (C) The OpenCRVS Authors located at https://github.com/opencrvs/opencrvs-core/blob/master/AUTHORS.\n */\nimport { MessageDescriptor } from 'react-intl'\nimport { formMessageDescriptors } from './common/messages'\nimport { Conditional, SerializedFormField } from './types/types'\nimport { getCustomFieldMapping } from '@countryconfig/utils/mapping/field-mapping-utils'\nimport { getNationalIDValidators } from './common/default-validation-conditionals'\nimport { camelCase } from 'lodash'\nimport { uppercaseFirstLetter } from '@countryconfig/utils'\n\n// ======================= CUSTOM FIELD CONFIGURATION =======================\n\n// A CUSTOM FIELD CAN BE ADDED TO APPEAR IN ANY SECTION\n// DUPLICATE AND RENAME FUNCTIONS LIKE THESE IN ORDER TO USE SIMILAR FIELDS\n\nexport function createCustomFieldExample(): SerializedFormField {\n  // GIVE THE FIELD A UNIQUE NAME.  IF THE NAME IS ALREADY IN USE, YOU WILL NOTICE AN ERROR ON PAGE LOAD IN DEVELOPMENT\n  const fieldName: string = 'favoriteColor'\n  // THE fieldId STRING IS A DOT SEPARATED STRING AND IS IMPORTANT TO SET CORRECTLY DEPENDING ON WHERE THE CUSTOM FIELD IS LOCATED\n  // THE FORMAT IS event.sectionId.groupId.uniqueFieldName\n  const fieldId: string = `birth.child.child-view-group.${fieldName}`\n  // IN ORDER TO USE THE VALUE ON A CERTIFICATE\n  // THE groupId IS IGNORED AND THE HANDLEBAR WILL LOG IN THE CONSOLE\n  // IN THIS EXAMPLE, IT WILL RESOLVE IN CAMELCASE TO \"{{birthChildFavouriteColor}}\"\n\n  return {\n    name: fieldName,\n    customQuestionMappingId: fieldId,\n    custom: true,\n    required: true,\n    type: 'TEXT', // ANY FORM FIELD TYPE IS POSSIBLE. ADD ADDITIONAL PROPS AS REQUIRED.  REFER TO THE form/README.md FILE\n    label: {\n      id: 'form.customField.label.favoriteColor',\n      description: 'A form field that asks for the persons favorite color.',\n      defaultMessage: 'What is your favorite color?'\n    },\n    initialValue: '',\n    validator: [], // EDIT VALIDATORS AS YOU SEE FIT\n    mapping: getCustomFieldMapping(fieldId), // ALL CUSTOM FIELDS MUST USE THIS MAPPING FUNCTION\n    conditionals: [], // EDIT CONDITIONALS AS YOU SEE FIT\n    maxLength: 250\n  }\n}\n\nexport function getMiddleNameField(\n  middleName: string,\n  previewGroup: string,\n  conditionals: Conditional[]\n): SerializedFormField {\n  // GIVE THE FIELD A UNIQUE NAME.  IF THE NAME IS ALREADY IN USE, YOU WILL NOTICE AN ERROR ON PAGE LOAD IN DEVELOPMENT\n  const fieldName: string = 'middleNamesEng'\n  // THE fieldId STRING IS A DOT SEPARATED STRING AND IS IMPORTANT TO SET CORRECTLY DEPENDING ON WHERE THE CUSTOM FIELD IS LOCATED\n  // THE FORMAT IS event.sectionId.groupId.uniqueFieldName\n  let lol\n\n  switch (middleName) {\n    case 'child':\n      lol = 'birth.child.child-view-group'\n      break\n    case 'mother':\n      lol = 'birth.mother.mother-view-group'\n      break\n    case 'father':\n      lol = 'birth.father.father-view-group'\n      break\n    case 'informant':\n      lol = 'birth.informant.informant-view-group'\n      break\n    default:\n      lol = 'birth.child.father-view-group' // Or a more appropriate default based on your logic\n  }\n  const fieldId: string = `${lol}.${fieldName}`\n  // IN ORDER TO USE THE VALUE ON A CERTIFICATE\n  // THE groupId IS IGNORED AND THE HANDLEBAR WILL LOG IN THE CONSOLE\n  // IN THIS EXAMPLE, IT WILL RESOLVE IN CAMELCASE TO \"{{birthChildFavouriteColor}}\"\n\n  return {\n    name: fieldName,\n    previewGroup,\n    conditionals,\n    customQuestionMappingId: fieldId,\n    custom: true,\n    required: true,\n    type: 'TEXT', // ANY FORM FIELD TYPE IS POSSIBLE. ADD ADDITIONAL PROPS AS REQUIRED.  REFER TO THE form/README.md FILE\n    label: formMessageDescriptors.middleName,\n    initialValue: '',\n    validator: [\n      {\n        operation: 'englishOnlyNameFormat'\n      }\n    ], // EDIT VALIDATORS AS YOU SEE FIT\n    mapping: getCustomFieldMapping(fieldId), // ALL CUSTOM FIELDS MUST USE THIS MAPPING FUNCTION\n    maxLength: 32\n  }\n}\n\nexport function getSpecifyRankField(): SerializedFormField {\n  // GIVE THE FIELD A UNIQUE NAME.  IF THE NAME IS ALREADY IN USE, YOU WILL NOTICE AN ERROR ON PAGE LOAD IN DEVELOPMENT\n  const fieldName: string = 'specifyRank'\n  // THE fieldId STRING IS A DOT SEPARATED STRING AND IS IMPORTANT TO SET CORRECTLY DEPENDING ON WHERE THE CUSTOM FIELD IS LOCATED\n  // THE FORMAT IS event.sectionId.groupId.uniqueFieldName\n  const fieldId: string = `birth.child.child-view-group.${fieldName}`\n  // IN ORDER TO USE THE VALUE ON A CERTIFICATE\n  // THE groupId IS IGNORED AND THE HANDLEBAR WILL LOG IN THE CONSOLE\n  // IN THIS EXAMPLE, IT WILL RESOLVE IN CAMELCASE TO \"{{birthChildFavouriteColor}}\"\n\n  return {\n    name: fieldName,\n    customQuestionMappingId: fieldId,\n    custom: true,\n    required: false,\n    type: 'NUMBER', // ANY FORM FIELD TYPE IS POSSIBLE. ADD ADDITIONAL PROPS AS REQUIRED.  REFER TO THE form/README.md FILE\n    label: formMessageDescriptors.specifyRank,\n    initialValue: '',\n    validator: [\n      {\n        operation: 'greaterThanZero'\n      },\n      {\n        operation: 'maxLength',\n        parameters: [2]\n      }\n    ], // EDIT VALIDATORS AS YOU SEE FIT\n    mapping: getCustomFieldMapping(fieldId), // ALL CUSTOM FIELDS MUST USE THIS MAPPING FUNCTION\n    conditionals: [\n      {\n        action: 'hide',\n        expression: `((values.birthType===\"SINGLE\") || (!values.birthType))`\n      }\n    ] // EDIT CONDITIONALS AS YOU SEE FIT\n  }\n}\n\nexport function getAgeTimeOfbirthField(ageBirth: string): SerializedFormField {\n  // GIVE THE FIELD A UNIQUE NAME.  IF THE NAME IS ALREADY IN USE, YOU WILL NOTICE AN ERROR ON PAGE LOAD IN DEVELOPMENT\n  const fieldName: string = 'ageTimeOfbirth'\n  // THE fieldId STRING IS A DOT SEPARATED STRING AND IS IMPORTANT TO SET CORRECTLY DEPENDING ON WHERE THE CUSTOM FIELD IS LOCATED\n  // THE FORMAT IS event.sectionId.groupId.uniqueFieldName\n  let age\n\n  switch (ageBirth) {\n    case 'mother':\n      age = 'birth.mother.mother-view-group'\n      break\n    case 'father':\n      age = 'birth.father.father-view-group'\n      break\n    default:\n      age = 'birth.child.father-view-group' // Or a more appropriate default based on your logic\n  }\n  const fieldId: string = `${age}.${fieldName}`\n  // IN ORDER TO USE THE VALUE ON A CERTIFICATE\n  // THE groupId IS IGNORED AND THE HANDLEBAR WILL LOG IN THE CONSOLE\n  // IN THIS EXAMPLE, IT WILL RESOLVE IN CAMELCASE TO \"{{birthChildFavouriteColor}}\"\n\n  return {\n    name: fieldName,\n    customQuestionMappingId: fieldId,\n    custom: true,\n    required: false,\n    type: 'NUMBER', // ANY FORM FIELD TYPE IS POSSIBLE. ADD ADDITIONAL PROPS AS REQUIRED.  REFER TO THE form/README.md FILE\n    label: formMessageDescriptors.ageTimeOfbirth,\n    initialValue: '',\n    validator: [\n      {\n        operation: 'greaterThanZero',\n        parameters: [8]\n      },\n      {\n        operation: 'maxLength',\n        parameters: [2]\n      }\n    ], // EDIT VALIDATORS AS YOU SEE FIT\n    mapping: getCustomFieldMapping(fieldId), // ALL CUSTOM FIELDS MUST USE THIS MAPPING FUNCTION\n    conditionals: [] // EDIT CONDITIONALS AS YOU SEE FIT\n  }\n}\n\nexport function getDateMarriageField(): SerializedFormField {\n  // GIVE THE FIELD A UNIQUE NAME.  IF THE NAME IS ALREADY IN USE, YOU WILL NOTICE AN ERROR ON PAGE LOAD IN DEVELOPMENT\n  const fieldName: string = 'dateMarriageOfParents'\n  // THE fieldId STRING IS A DOT SEPARATED STRING AND IS IMPORTANT TO SET CORRECTLY DEPENDING ON WHERE THE CUSTOM FIELD IS LOCATED\n  // THE FORMAT IS event.sectionId.groupId.uniqueFieldName\n  const fieldId: string = `birth.father.father-view-group.${fieldName}`\n  // IN ORDER TO USE THE VALUE ON A CERTIFICATE\n  // THE groupId IS IGNORED AND THE HANDLEBAR WILL LOG IN THE CONSOLE\n  // IN THIS EXAMPLE, IT WILL RESOLVE IN CAMELCASE TO \"{{birthChildFavouriteColor}}\"\n\n  return {\n    name: fieldName,\n    customQuestionMappingId: fieldId,\n    custom: true,\n    required: true,\n    type: 'DATE', // ANY FORM FIELD TYPE IS POSSIBLE. ADD ADDITIONAL PROPS AS REQUIRED.  REFER TO THE form/README.md FILE\n    label: formMessageDescriptors.dateMarriageOfParents,\n    initialValue: '',\n    validator: [\n      {\n        operation: 'dateFormatIsCorrect',\n        parameters: []\n      },\n      {\n        operation: 'dateInPast',\n        parameters: []\n      }\n    ], // EDIT VALIDATORS AS YOU SEE FIT\n    mapping: getCustomFieldMapping(fieldId), // ALL CUSTOM FIELDS MUST USE THIS MAPPING FUNCTION\n    conditionals: [\n      {\n        action: 'hide',\n        expression: `((values.maritalStatus===\"SINGLE\") || (values.maritalStatus===\"WIDOWED\") || (values.maritalStatus===\"DIVORCED\") || (values.maritalStatus===\"SEPARATED\") || (values.maritalStatus===\"NOT_STATED\") || (!values.maritalStatus))`\n      }\n    ] // EDIT CONDITIONALS AS YOU SEE FIT\n  }\n}\n\nexport function getBirthOrderField(): SerializedFormField {\n  // GIVE THE FIELD A UNIQUE NAME.  IF THE NAME IS ALREADY IN USE, YOU WILL NOTICE AN ERROR ON PAGE LOAD IN DEVELOPMENT\n  const fieldName: string = 'birthOrder'\n  // THE fieldId STRING IS A DOT SEPARATED STRING AND IS IMPORTANT TO SET CORRECTLY DEPENDING ON WHERE THE CUSTOM FIELD IS LOCATED\n  // THE FORMAT IS event.sectionId.groupId.uniqueFieldName\n  const fieldId: string = `birth.child.child-view-group.${fieldName}`\n  // IN ORDER TO USE THE VALUE ON A CERTIFICATE\n  // THE groupId IS IGNORED AND THE HANDLEBAR WILL LOG IN THE CONSOLE\n  // IN THIS EXAMPLE, IT WILL RESOLVE IN CAMELCASE TO \"{{birthChildFavouriteColor}}\"\n\n  return {\n    name: fieldName,\n    customQuestionMappingId: fieldId,\n    custom: true,\n    required: false,\n    type: 'NUMBER', // ANY FORM FIELD TYPE IS POSSIBLE. ADD ADDITIONAL PROPS AS REQUIRED.  REFER TO THE form/README.md FILE\n    label: formMessageDescriptors.birthOrder,\n    initialValue: '',\n    validator: [\n      {\n        operation: 'greaterThanZero'\n      },\n      {\n        operation: 'maxLength',\n        parameters: [2]\n      }\n    ], // EDIT VALIDATORS AS YOU SEE FIT\n    mapping: getCustomFieldMapping(fieldId), // ALL CUSTOM FIELDS MUST USE THIS MAPPING FUNCTION\n    conditionals: [] // EDIT CONDITIONALS AS YOU SEE FIT\n  }\n}\n\nexport function getTotalNumberOfChildrenBornAliveField(): SerializedFormField {\n  // GIVE THE FIELD A UNIQUE NAME.  IF THE NAME IS ALREADY IN USE, YOU WILL NOTICE AN ERROR ON PAGE LOAD IN DEVELOPMENT\n  const fieldName: string = 'totalNumberOfChildrenBornAlive'\n  // THE fieldId STRING IS A DOT SEPARATED STRING AND IS IMPORTANT TO SET CORRECTLY DEPENDING ON WHERE THE CUSTOM FIELD IS LOCATED\n  // THE FORMAT IS event.sectionId.groupId.uniqueFieldName\n  const fieldId: string = `birth.mother.mother-view-group.${fieldName}`\n  // IN ORDER TO USE THE VALUE ON A CERTIFICATE\n  // THE groupId IS IGNORED AND THE HANDLEBAR WILL LOG IN THE CONSOLE\n  // IN THIS EXAMPLE, IT WILL RESOLVE IN CAMELCASE TO \"{{birthChildFavouriteColor}}\"\n\n  return {\n    name: fieldName,\n    customQuestionMappingId: fieldId,\n    custom: true,\n    required: false,\n    type: 'NUMBER', // ANY FORM FIELD TYPE IS POSSIBLE. ADD ADDITIONAL PROPS AS REQUIRED.  REFER TO THE form/README.md FILE\n    label: formMessageDescriptors.totalNumberOfChildrenBornAlive,\n    initialValue: '',\n    validator: [\n      {\n        operation: 'greaterThanZero',\n        parameters: [50]\n      },\n      {\n        operation: 'maxLength',\n        parameters: [2]\n      }\n    ], // EDIT VALIDATORS AS YOU SEE FIT\n    mapping: getCustomFieldMapping(fieldId), // ALL CUSTOM FIELDS MUST USE THIS MAPPING FUNCTION\n    conditionals: [] // EDIT CONDITIONALS AS YOU SEE FIT\n  }\n}\n\nexport function getChildrenStillLivingIncludingThisBirthField(): SerializedFormField {\n  // GIVE THE FIELD A UNIQUE NAME.  IF THE NAME IS ALREADY IN USE, YOU WILL NOTICE AN ERROR ON PAGE LOAD IN DEVELOPMENT\n  const fieldName: string = 'childrenStillLivingIncludingThisBirth'\n  // THE fieldId STRING IS A DOT SEPARATED STRING AND IS IMPORTANT TO SET CORRECTLY DEPENDING ON WHERE THE CUSTOM FIELD IS LOCATED\n  // THE FORMAT IS event.sectionId.groupId.uniqueFieldName\n  const fieldId: string = `birth.mother.mother-view-group.${fieldName}`\n  // IN ORDER TO USE THE VALUE ON A CERTIFICATE\n  // THE groupId IS IGNORED AND THE HANDLEBAR WILL LOG IN THE CONSOLE\n  // IN THIS EXAMPLE, IT WILL RESOLVE IN CAMELCASE TO \"{{birthChildFavouriteColor}}\"\n\n  return {\n    name: fieldName,\n    customQuestionMappingId: fieldId,\n    custom: true,\n    required: false,\n    type: 'NUMBER', // ANY FORM FIELD TYPE IS POSSIBLE. ADD ADDITIONAL PROPS AS REQUIRED.  REFER TO THE form/README.md FILE\n    label: formMessageDescriptors.childrenStillLivingIncludingThisBirth,\n    initialValue: '',\n    validator: [\n      {\n        operation: 'greaterThanZero',\n        parameters: [50]\n      },\n      {\n        operation: 'maxLength',\n        parameters: [2]\n      }\n    ], // EDIT VALIDATORS AS YOU SEE FIT\n    mapping: getCustomFieldMapping(fieldId), // ALL CUSTOM FIELDS MUST USE THIS MAPPING FUNCTION\n    conditionals: [] // EDIT CONDITIONALS AS YOU SEE FIT\n  }\n}\n\nexport function getReasonForLateRegistration(\n  event: string\n): SerializedFormField {\n  const fieldName: string = 'reasonForLateRegistration'\n  const fieldId: string =\n    event === 'birth'\n      ? `birth.child.child-view-group.${fieldName}`\n      : `death.deathEvent.death-event-details.${fieldName}`\n  const label: MessageDescriptor =\n    event === 'birth'\n      ? {\n          id: 'form.customField.label.reasonForLateRegistrationBirth',\n          description:\n            'A form field that asks the reason for a late registration.',\n          defaultMessage: 'Reason for delayed registration'\n        }\n      : {\n          id: 'form.customField.label.reasonForLateRegistrationDeath',\n          description:\n            'A form field that asks the reason for a late registration.',\n          defaultMessage: 'Reason for late registration'\n        }\n  const expression: string =\n    event === 'birth'\n      ? 'const pattern = /^\\\\d{4}-\\\\d{1,2}-\\\\d{1,2}$/; const today = new Date(); const eventDatePlusLateRegistrationTarget = new Date(values.childBirthDate); const lateRegistrationTarget = offlineCountryConfig && offlineCountryConfig.config.BIRTH.LATE_REGISTRATION_TARGET; eventDatePlusLateRegistrationTarget.setDate(eventDatePlusLateRegistrationTarget.getDate() + lateRegistrationTarget); !pattern.test(values.childBirthDate) || today < eventDatePlusLateRegistrationTarget;'\n      : 'const pattern = /^\\\\d{4}-\\\\d{1,2}-\\\\d{1,2}$/; const today = new Date(); const eventDatePlusLateRegistrationTarget = new Date(values.deathDate); const lateRegistrationTarget = offlineCountryConfig && offlineCountryConfig.config.DEATH.REGISTRATION_TARGET; eventDatePlusLateRegistrationTarget.setDate(eventDatePlusLateRegistrationTarget.getDate() + lateRegistrationTarget); !pattern.test(values.deathDate) || today < eventDatePlusLateRegistrationTarget;'\n\n  return {\n    name: fieldName,\n    customQuestionMappingId: fieldId,\n    custom: true,\n    required: true,\n    type: 'TEXT',\n    label,\n    initialValue: '',\n    validator: [],\n    mapping: getCustomFieldMapping(fieldId),\n    conditionals: [\n      {\n        action: 'hide',\n        expression\n      }\n    ], // EDIT CONDITIONALS AS YOU SEE FIT\n    maxLength: 250\n  }\n}\n\ntype ArrayElement<ArrayType> = ArrayType extends readonly (infer ElementType)[]\n  ? ElementType\n  : never\n\nconst idTypeOptions = [\n  {\n    value: 'NATIONAL_ID' as const,\n    label: {\n      defaultMessage: 'National ID',\n      description: 'Option for form field: Type of ID',\n      id: 'form.field.label.iDTypeNationalID'\n    }\n  },\n  {\n    value: 'PASSPORT' as const,\n    label: {\n      defaultMessage: 'Passport',\n      description: 'Option for form field: Type of ID',\n      id: 'form.field.label.iDTypePassport'\n    }\n  },\n  {\n    value: 'BIRTH_REGISTRATION_NUMBER' as const,\n    label: {\n      defaultMessage: 'Birth Registration Number',\n      description: 'Option for form field: Type of ID',\n      id: 'form.field.label.iDTypeBRN'\n    }\n  },\n  {\n    value: 'NONE' as const,\n    label: {\n      defaultMessage: 'None',\n      description: 'Option for form field: Type of ID',\n      id: 'form.field.label.iDTypeNone'\n    }\n  }\n]\n\ntype IDType = ArrayElement<typeof idTypeOptions>['value']\n\nexport function getIDType(\n  event: string,\n  sectionId: string,\n  conditionals: Conditional[] = [],\n  required: boolean\n): SerializedFormField {\n  const fieldName: string = `${sectionId}IdType`\n  const fieldId: string = `${event}.${sectionId}.${sectionId}-view-group.${fieldName}`\n  return {\n    name: fieldName,\n    customQuestionMappingId: fieldId,\n    custom: true,\n    required,\n    type: 'SELECT_WITH_OPTIONS',\n    label: {\n      id: 'form.field.label.iDType',\n      description: 'A form field that asks for the type of ID.',\n      defaultMessage: 'Type of ID'\n    },\n    initialValue: '',\n    validator: [],\n    mapping: getCustomFieldMapping(fieldId),\n    placeholder: formMessageDescriptors.formSelectPlaceholder,\n    conditionals,\n    options: idTypeOptions\n  }\n}\n\nfunction getValidators(configCase: string, idValue: IDType) {\n  if (idValue === 'NATIONAL_ID') {\n    return getNationalIDValidators(configCase)\n  }\n  return []\n}\n\nexport function getIDNumber(\n  sectionId: string,\n  idValue: IDType,\n  conditionals: Conditional[] = [],\n  required: boolean\n): SerializedFormField {\n  const fieldName: string = `${sectionId}${uppercaseFirstLetter(\n    camelCase(idValue)\n  )}`\n  const validators = getValidators(sectionId, idValue)\n  // eslint-disable-next-line no-console\n  console.log('Custom field addded with handlebar: ', fieldName)\n  return {\n    name: fieldName,\n    required,\n    type: 'TEXT',\n    custom: true,\n    label: {\n      id: 'form.field.label.iD',\n      description: 'A form field that asks for the id number.',\n      defaultMessage: 'ID number'\n    },\n    initialValue: '',\n    validator: validators,\n    mapping: {\n      template: {\n        fieldName: fieldName,\n        operation: 'identityToFieldTransformer',\n        parameters: ['id', idValue]\n      },\n      mutation: {\n        operation: 'fieldToIdentityTransformer',\n        parameters: ['id', idValue]\n      },\n      query: {\n        operation: 'identityToFieldTransformer',\n        parameters: ['id', idValue]\n      }\n    },\n    conditionals: [\n      {\n        action: 'hide',\n        expression: `(values.${sectionId}IdType!==\"${idValue}\") || (values.${sectionId}IdType===\"NONE\")`\n      }\n    ].concat(conditionals),\n    maxLength: 250\n  }\n}\n\nexport function getIDNumberFields(\n  section: string,\n  conditionals: Conditional[] = [],\n  required: boolean\n) {\n  return idTypeOptions\n    .filter((opt) => opt.value !== 'NONE')\n    .map((opt) => getIDNumber(section, opt.value, conditionals, required))\n}\n"
        }
    ]
}